mock_scdata <- function(filt_cell_id = "") {
  data("pbmc_small", package = "SeuratObject", envir = environment())
  pbmc_small$cells_id <- 0:(ncol(pbmc_small) - 1)
  if (all(filt_cell_id != "")) {
    keep_cells_id <- which(!pbmc_small$cells_id %in% filt_cell_id)
    keep_cells <- names(pbmc_small$cells_id[keep_cells_id])
    pbmc_small <- subset(pbmc_small, cells = keep_cells)
  }
  pbmc_small@misc$gene_annotations <- data.frame(
    input = row.names(pbmc_small),
    name = row.names(pbmc_small),
    row.names = row.names(pbmc_small)
  )

  # scale and PCA
  pbmc_small <- Seurat::NormalizeData(pbmc_small, normalization.method = "LogNormalize", verbose = FALSE)
  pbmc_small <- Seurat::FindVariableFeatures(pbmc_small, verbose = FALSE)
  pbmc_small <- Seurat::ScaleData(pbmc_small, verbose = FALSE)
  pbmc_small <- Seurat::RunPCA(pbmc_small, verbose = FALSE, npcs = 10)
  pbmc_small@misc[["active.reduction"]] <- "pca"

  # run UMAP
  npcs <- get_npcs(pbmc_small)
  pbmc_small <- suppressWarnings(Seurat::RunUMAP(pbmc_small, dims = 1:npcs, verbose = FALSE))

  return(pbmc_small)
}

get_explained_variance <- function(scdata) {
  # Compute explained variance for plotting and numPCs estimation.
  # It can be computed from pca or other reductions such as mnn
  if (scdata@misc[["active.reduction"]] == "mnn") {
    var_explained <- scdata@tools$`SeuratWrappers::RunFastMNN`$pca.info$var.explained
  } else {
    eig_values <- (scdata@reductions$pca@stdev)^2
    var_explained <- eig_values / sum(eig_values)
  }
  return(var_explained)
}

get_npcs <- function(scdata, var_threshold = 0.85, max_npcs = 30) {
  # estimates the number of PCs to use in data integration and embeddings,
  # using accumulated explained variance
  var_explained <- get_explained_variance(scdata)
  npcs <- min(which(cumsum(var_explained) >= var_threshold))
  return(min(npcs, max_npcs, na.rm = TRUE))
}


mock_req <- function() {
  req <- list(
    body = list(
      rootNodes = c("Y_1", "Y_2", "Y_3")
    )
  )
}


test_that("generateGraphData converts Seurat object to Monocle3 cell_data_set object", {
  data <- mock_scdata()

  cell_data <- suppressWarnings(generateGraphData(data))

  expect_s4_class(cell_data, "cell_data_set")
})

test_that("runGenerateTrajectoryGraph returns an object of class character", {
  data <- mock_scdata()

  node_umap_coords <- suppressWarnings(runGenerateTrajectoryGraph(req, data))

  expect_type(node_umap_coords, "character")
})


test_that("runGenerateTrajectoryGraph json output has the expected list format when converted back to list", {
  data <- mock_scdata()

  node_umap_coords <- suppressWarnings(runGenerateTrajectoryGraph(req, data))

  # convert back to list from json
  item <- RJSONIO::fromJSON(node_umap_coords)
  expect_named(item, c("nodes", "umap"))
  expect_named(item$nodes[[1]], c("x", "y", "node_id", "connected_nodes"))
  expect_named(item$umap[[1]], c("x", "y"))
  expect_type(item$nodes[[1]]$x, "double")
  expect_type(item$nodes[[1]]$y, "double")
  expect_type(item$nodes[[1]]$node_id, "character")
  expect_type(item$nodes[[1]]$connected_nodes, "character")
  expect_type(item$umap[[1]], "double")
})


test_that("runGenerateTrajectoryGraph fills in NULL values in UMAP coordinates for filtered cells", {
  filt_cell_id <- c(2, 5, 6)
  data <- mock_scdata(filt_cell_id = filt_cell_id)

  node_umap_coords <- suppressWarnings(runGenerateTrajectoryGraph(req, data))
  # convert back to list from json
  item <- RJSONIO::fromJSON(node_umap_coords)

  # check that the number of cell ids for umap coords is the same as the number of cell ids of the unfiltered object
  expect_equal(length(item$umap), (length(data$cells_id) + length(filt_cell_id)))
  # check that filtered cells have NULL values
  expect_equal(unlist(item$umap[filt_cell_id + 1]), NULL)
})


test_that("json generated by runGenerateTrajectoryGraph has the correct number of nodes", {
  data <- mock_scdata()

  cell_data <- suppressWarnings(generateGraphData(data))
  node_umap_coords <- suppressWarnings(runGenerateTrajectoryGraph(req, data))
  # convert back to list from json
  item <- RJSONIO::fromJSON(node_umap_coords)

  expect_equal(nrow(t(cell_data@principal_graph_aux[["UMAP"]]$dp_mst)), length(item$nodes))
})


test_that("runTrajectoryAnalysis works", {
  data <- mock_scdata()
  req <- mock_req()

  pseudotime <- suppressWarnings(runTrajectoryAnalysis(req, data))

  expect_equal(length(data$cells_id), nrow(pseudotime))
  expect_true(sapply(pseudotime, is.numeric))
})
