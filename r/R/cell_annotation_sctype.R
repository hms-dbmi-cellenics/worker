#' Annotate cells with ScType
#'
#' This function uses [ScType](https://github.com/IanevskiAleksandr/sc-type)
#' to annotate cells in a Seurat object.
#'
#' As a preprocessing step, it downloads the cellsets file from s3, parses it
#' and adds the information as metadata columns in the metadata slot of the Seurat object.
#' It annotates the cells using ScType, based on Louvain clusters. The annotations
#' are temporarily added as a new column in the metadata slot of the Seurat object.
#' Finally, it updates the cellsets object via the API with the cluster-level
#' annotations generated by ScType.
#'
#'
#' @param req list with items:
#'  \code{req$body$cellSets} cellsets object
#'  \code{req$body$species} either "human" or "mouse"
#'  \code{req$body$tissue} one of: Immune system, Pancreas, Liver, Eye, Kidney, Brain, Lung, Adrenal, Heart, Intestine, Muscle, Placenta, Spleen, Stomach, Thymus
#'
#' @param data Seurat object
#'
#' @export
#'
ScTypeAnnotate <- function(req, data) {
  cell_sets <- req$body$cellSets
  species <- req$body$species
  tissue <- req$body$tissue



  if ("integrated" %in% names(data@assays)) {
    active_assay <- "integrated"
  } else if ("SCT" %in% names(data@assays)) {
    active_assay <- "SCT"
  } else {
    active_assay <- "RNA"
  }

  scale_data <- get_formatted_data(data, active_assay)

  children_cell_sets <- sapply(cell_sets, `[[`, "children")
  parsed_cellsets <- parse_cellsets(children_cell_sets)

  data <- add_clusters(data, parsed_cellsets, cell_sets)

  data[[active_assay]]@scale.data <- scale_data
  data <- run_sctype(data, active_assay, tissue, species)

  formatted_cell_class <- format_sctype_cell_sets(data, species, tissue)

  updateCellSetsThroughApi(
    formatted_cell_class,
    req$body$apiUrl,
    req$body$experimentId,
    formatted_cell_class$key,
    req$body$authJwt
  )

  return(formatted_cell_class)
}


#' Format count matrix for ScType
#'
#' This function extracts the scaled count matrix from the Seurat object, adds
#' gene symbols as rownames, and collapses duplicated gene symbols.
#' The formatted count matrix will be used by ScType to annotate cells.
#'
#' @param scdata Seurat object
#' @param active_assay string. One of: RNA, SCT, integrated. It's to extract scale.data
#'
#' @return formatted scaled count matrix
#' @export
#'
#' @examples
get_formatted_data <- function(scdata, active_assay) {

  scale_data <- scdata[[active_assay]]@scale.data

  # no hvgs or scale.data if seurat object was uploaded
  if (sum(dim(scale_data)) == 0) {
    scdata <- Seurat::FindVariableFeatures(scdata)
    scdata <- Seurat::ScaleData(scdata)
    scale_data <- scdata[[active_assay]]@scale.data
  }

  scale_data <- data.table::as.data.table(scale_data, keep.rownames = "input")

  scale_data <- add_gene_symbols(scale_data, scdata)

  scale_data <- collapse_genes(scale_data)

  scale_data <- format_matrix(scale_data)

  return(scale_data)
}


#' Add gene symbols to count matrix
#'
#' This function adds gene symbols to a count matrix.
#' It takes the gene symbols from the misc slot of the Seurat object, which
#' is created in the pipeline.
#'
#' @param scale_data data.frame. Count matrix
#' @param scdata Seurat object
#'
#' @return count matrix with gene symbols in the new column "original_name"
#' @export
#'
add_gene_symbols <- function(scale_data, scdata) {
  annot <- data.table::as.data.table(scdata@misc$gene_annotations)
  annot <- annot[, .(input, original_name)]

  feature_types <- get_feature_types(annot)
  if (feature_types == IDS_IDS) {
    stop(
      generateErrorMessage(
        error_codes$NO_GENE_SYMBOLS,
        "Features file doesn't contain gene symbols."
      )
    )
  }

  scale_data <- annot[scale_data, on = .(input)]

  return(scale_data)
}

#' Collapse gene symbols
#'
#' This function collapses rows of the count matrix by gene symbols.
#' For each duplicated gene symbol, it takes the row with the highest mean expression.
#'
#' @param scale_data count matrix
#'
#' @return collapsed count matrix
#' @export
#'
collapse_genes <- function(scale_data) {
  # take gene with highest mean expression for duplicated gene symbols
  scale_data[, mean_expression := rowMeans(.SD), .SDcols = !c("input", "original_name")]
  scale_data <- scale_data[!duplicated(scale_data, by = "original_name") | mean_expression == max(mean_expression), ]
  scale_data[, mean_expression := NULL]

  return(scale_data)
}


#' Format count matrix for ScType
#'
#' This function format the count matrix as a matrix with gene symbols as rownames.
#'
#' @param scale_data data.frame. Count matrix
#'
#' @return formatted count matrix
#' @export
#'
format_matrix <- function(scale_data) {
  scale_data <- scale_data[, -"input"]
  scale_data <- as.matrix(scale_data, rownames = "original_name")

  return(scale_data)
}


#' Run ScType
#'
#' This function runs ScType on the scale.data slot of a Seurat object
#' producing cell-level annotations that are then merged by cluster.
#' For more information about ScType see [this link](https://github.com/IanevskiAleksandr/sc-type).
#' It adds the resulting annotations as a new column named "customclassif" to the
#' metadata slot of the Seurat object.
#'
#' @param data Seurat object
#' @param active_assay string. One of: RNA, SCT, integrated. It's to extract scale.data.
#' @param tissue string. Tissue information coming from the config. It's used to extract marker genes from the database
#' @param species string. Species information. Either "human" or "mouse"
#'
#' @return Seurat object with ScType annotations in the metadata slot
#' @export
#'
run_sctype <- function(data, active_assay, tissue, species) {
  library(openxlsx)
  library(HGNChelper)

  source("http://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
  source("http://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

  db <- "http://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx"
  gs_list <- gene_sets_prepare(db, tissue)


  # get cell-type by cell matrix
  cell_type_scores <- sctype_score(
    scRNAseqData = data[[active_assay]]@scale.data, scaled = TRUE,
    gs = gs_list$gs_positive, gs2 = gs_list$gs_negative
  )

  # merge by cluster
  clusters <- "seurat_clusters"
  metadata_clusters <- data@meta.data[[clusters]]

  # Remove rownames that aren't numbers, as.integer won't work otherwise
  rownames(data@meta.data) <- NULL

  # from https://github.com/IanevskiAleksandr/sc-type/blob/master/README.md
  cluster_scores <- do.call("rbind", lapply(unique(metadata_clusters), function(cl) {
    cell_type_scores_cl <- sort(rowSums(cell_type_scores[, as.integer(rownames(data@meta.data[metadata_clusters == cl, ]))]), decreasing = !0)

    head(data.frame(cluster = cl, type = names(cell_type_scores_cl), scores = cell_type_scores_cl, ncells = sum(metadata_clusters == cl)), 10)

  }))

  sctype_scores <- cluster_scores |>
    dplyr::group_by(cluster) |>
    dplyr::top_n(n = 1, wt = scores)

  # set low-confident (low ScType score) clusters to "unknown" (threshold defined by ScType authors)
  sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells / 4] <- "Unknown"


  data@meta.data$customclassif <- ""
  for (j in unique(sctype_scores$cluster)) {
    cl_type <- sctype_scores[sctype_scores$cluster == j, ]
    data@meta.data$customclassif[metadata_clusters == j] <- as.character(cl_type$type[1])
  }

  return(data)
}
